abstraction:A description of something that omits some details that are not relevant to the purpose of the abstraction. It is the converse of refinement Abstraction in programming is the process of identifying common patterns that have systematic variations an abstraction represents the common pattern and provides a means for specifying which variation to use. 
adaptability:Adaptability concerns the alteration of a system to fit the needs of a user without necessarily changing it from one machine to another. 
adaptive maintenance:Modification of a software product performed after delivery to keep a computer program usable in a changed or changing environment 
alternative hypothesis :The hypothesis that remains tenable when the null hypothesis is rejected The alternative hypothesis posits that there is no significant difference between two treatments with respect to the dependent variable you are measuring . See also null hypothesis, statistical hypothesis.
analysis:The phase in the software life-cycle that emphasises on investigation of what the problem is rather than how a solution must be defined.
architecture:The organizational structure of a system or component The fundamental organisation of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and evolution. The architecture of a software system is the structural and behavioural framework on which all other aspects of the system depend. It is the organisational structure of a software system including components, connections, constraints, and rationale.
architectural style:A family of architectures constrained bycomponent connector vocabulary, topology, semantic constraints. 
architectural design: The process of defining a collection of hardware and software components and their interfaces to establish the framework for the development of a computer system. The result of the process in . That part of the design phase where the software architecture is defined.
architecture description: A collection of products to document an architecture. 
artefact:The result of any activity in the software life-cycle such as requirements, architecture model, design specifications, source code and test scripts A piece of information that is used or produced by a software development process. An artifact can be a model, a description, or software.
asset:A collection of artefacts.
benchmark: A standard against which measurements or comparisons can be made. A problem, procedure, or test that can be used to compare systems or components to each other or to a standard as in . A recovery file. A benchmark is a set of tests used to compare the performance of alternative tools, methods, or techniques.
black-box reuse:A kind of reuse where a component is reused as is . Paul Bassett argues that this is not a kind of reuse, but simply a use of the component 
business model:A model of real-world objects and their interactions -or rather, some users' understanding of them 
business rule:A step or set of steps in a process or procedure or guide used by a customer for doing its business, work, or function, and often embodied in whole or in part in the software of a system 
Capability Maturity Model :Defined by the Software Engineering Institute at Carnegie Mellon University. Describes the level of capability and maturity a software team could aim for and could be assessed against.
case study:A case study is a research technique where you identify key factors that may affect the outcome of an activity and then document the activity its inputs, constraints, resources, and outputs. Case studies usually look at a typical project, rather than trying to capture information about all possible cases these can be thought of a "research in the typical". Formal experiments, case studies and surveys are three key components of empirical investigation in software engineering. 
change propagation:Occurs when making a change to one part of a software system requires other system parts that depend on it to be changed as well. These dependent system parts can on their turn require changes in other system parts. In this way, a single change to one system part may lead to a propagation of changes to be made throughout the entire software system.
cliche: A pattern describing salient features of a concept that supports recognition of that concept in some specified context by application of some specified comparison algorithm. A collection of related features or characteristics that provide a shared technical vocabulary, including inter-feature relationships. 
client interface of a class:The set of all methods exported by the class The client interface is used to access the functionality of objects. The interface is accessed by sending messages to objects, and the internal structure of the objects shouldn't be evident. See also specialisation interface
commonalities:The set of features or properties of a component that are the same, or common, between systems
compatibility:1. The ease of combining software elements with others 2. The ability of two or more systems or components to perform their required functions while sharing the same hardware or software environment 3. The ability of two or more systems or components to exchange information 
complexity:The degree to which a system or component has a design and implementation that is difficult to understand and verify That property of a language expression which makes it difficult to formulate its overall behaviour, even when given almost complete information about its atomic components and their inter-relations. 
component:1. A component is a high-quality workproduct, designed, documented, and packaged to be reusable. A component is cohesive and has a stable interface 2. A component is a physical and replaceable part of a system that conforms to and provides the realisation of a set of interfaces 
compression:Compression is the characteristic of a piece of text that the meaning of any part of it is "larger" than that particular piece has by itself. This characteristic is created by a rich context, with each part of the text drawing on that context - each word draws part of its meaning from its surroundings. 
concerns:Those interests which pertain to the system development, its operation or any other aspects that are critical or otherwise important to one or more stakeholders. Concerns can be logical or physiscal concepts, but they may also include system considerations such as performance, reliability, security, distribution, and evolvability. 
confidence interval:A range of values that, considering all possible samples, has some designated probability of including the true population value 
conformance:One behavioural description conforms to another if any object hat behavs as described by one also behaves as described by the other . A conformance is a relationship between the two descriptions, accompanied by a justification that includes the mapping between them and the rationale for the choices made. Refinement and conformance form the basis of traceability and document the answer to the "why" question Why is this design done in this way 
consistency:The degree of uniformity, standardization, and freedom from contradiction among the documents or parts of a system or component. 
copy-and-modify reuse :A widespread form of reuse where the reuser takes a copy of a component and starts modifying it without maintaining any form of consistency with the original component. In other words, there is no systematic way of keeping the two versions synchronised. The danger is of course a proliferation of versions, and an inability to upgrade to new versions of a component. This form of reuse only brings benefits on a very short-term basis.
corrective maintenance:Reactive modification of a software product performed after delivery to correct discovered faults 
correctness:The ability of software products to perform their exact tasks, as defined by their specification 
dependency analysis:Involves examining dependency relationships among software artefacts of the same kind, usually program entities . This definition is more or less the same as the one of vertical traceability.
dependency graph:A graph in which the nodes represent software artefacts, and the edges represent all different kinds of dependency relationships between these artefacts
design:The phase in the software life-cycle that emphasises a logical solution, i.e. how the system fulfills the requirements. During object-oriented design, there is an emphasis on defining logical software objects that will ultimately be implemented in an object-oriented programming language. In this view, the design serves as a high level description of the source code, describing its key features and giving a blueprint of how the code is organised. The process of defining the architecture, components, interfaces, and other characteristics of a system or component. The result of the process in . 
design recovery:A subset of reverse engineering in which domain knowledge, external information, and deduction or fuzzy reasoning are added to the observations of the subject system to identify meaningful higher-level abstractions beyond those obtained directly by examining the system itself. Design recovery recreates design abstractions from a combination of code, existing design documentation , personal experience, and general knowledge about problem and application domains. Design recovery must reproduce all of the information required for a person to fully understand what a program does, how it does it, why it does it, and so forth. Thus, it deals with a far wider range of information than found in conventional software engineering representations or code. 
detailed design: The process of refining and expanding the preliminary design of a system or component to the extent that the design is sufficiently complete to be implemented. The result of the process in . 
disciplined reuse:A form of reuse where a degree of consistency is maintained between the original component and its reusers. With disciplined reuse the benefits of reuse are much more sustainable.
domain:A problem area. Typically, many application programs exist to solve the problems in a single domain. The following prerequisites indicate the presence of a domain the existence of comprehensive relationships among objects in the domain, a community interested in solutions to the problems in the domain, a recognition that software solutions are appropriate to the problems in the domain, and a store of knowledge or collected wisdom to address the problems in the domain. Once recognized, a domain can be characterized by its vocabulary, common assumptions, architectural approach, and literature. An area of knowledge or activity characterized by a set of concepts and terminology understood by practitioners in that area The part of domain engineering that deals with identifying commonalities, similarities and variabilities of an application or an application domain .
domain engineering:A systematic way of defining, implementing and evolving a domain in terms of commonalities and variabilities
domain scoping:Domain scoping identifies the domains of interest, the stakeholders, and their goals, and defines the scope of the domain. 
domain modeling:Domain modeling is the activity for representing the domain, or the domain model. Typically a domain model is formed through a commonality and variability analysis to concepts in the domain. 
ease of use:The ease with which people of various backgrounds and qualifications can learn to use software products and apply them to solve problems. It also covers the ease of installation, operation and monitoring.
economy:Economy, seen as a software quality, is the ability of a system to be completed on or below its assigned budget 
efficiency:The ability of a software system to place as few demands as possible on hardware resources, such as processor time, space occupied in internal and external memories, bandwidth used in communication devices The degree to which a system or component performs its designated functions with minimum consumption of resources. In case of time resources we speak of execution efficiency. In case of available storage resources we speak of storage efficiency 
effort estimation:The process to estimate in advance the effort required to make a certain software change
emergency maintenance:Unscheduled corrective maintenance performed to keep a system operational 
engineering:The profession in which a knowledge of the mathematical and natural sciences gained by study, experience and practice is applied with judgement to develop ways to utilize, economically, the materials and forces of nature for the benefit of mankind See also software engineering
entropy:See software entropy
evolution:See software evolution
evolutionary software development:This is basically the same as iterative incremental software development, but the term stresses the fact that a software system is never completely finished, and that it continues to evolve after it has been delivered.
evolvability:The capability of software products to be evolved to continue to serve its customer in a cost effective way 
experiment:In general, an experiment is defined as an act or operation for the purpose of discovering something unknown or testing a principle, supposition, etc. In software engineering a trial that is conducted in order to verify a hypothesis defined beforehand in a controlled setting in which the most critical factors can be controlled or monitored A formal experiment is a rigorous, controlled investigation of an activity, where key factors are identified and manipulated to document their effects on the outcome. By their nature, since formal experiments require a great deal of control, they tend to be small, involving small numbers of people or events. We can think of experiments as "research in the small". Formal experiments, case studies and surveys are three key components of empirical investigation in software engineering. 
experimental error:Measure that includes all uncontrolled sources of variation affecting a particular score 
extendability:The ease with which a system or component can be modified to increase its storage or functional capacity The ease of adapting software products to changes of specification .
extensibility:See extendability
fact:Information considered to be objectively real because it was obtained through observation 
feature:A feature describes prominent or distinctive user-visible aspects, quality or characteristics of a software system or systems A feature is an observable and relatively closed behaviour or characteristic of a part .
flexibility:The ease with which a system or component can be modified for use in applications or environments other than those for which it was specifically designed 
formal experiment:See experiment.
formal method:A formal method of software development is a process for developing software that exploits the power of mathematical notation and mathematical proofs 
forward engineering:The traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation of a system Forward engineering is the traditional process of moving from high-level abstractions and logical, implementation-independent designs to the physical implementation of a system. Forward engineering follows a sequence of going from requirements through designing its implementation. 
fragile base class problem:Refers to the problem that occurs when independently developed subclasses are broken when their base class evolves.
framework:A framework is a reusable design of all or part of a software system described by a set of abstract classes and the way instances of those classes collaborate . A framework is a micro-architecture that provides an extensible template for applications within a specific domain .
functional design: The process of defining the working relationships among the components of a system. The result of the process in . 
functionality:The extent of possibilities provided by a system 
generality:The degree to which a system or component performs a broad range of functions 
habitability:The characteristic of source code that enables programmers, coders, bug-fixers and people coming to the code later in its life to understand its construction and intentions, and to change it comfortably and confidently. See also maintainability
heuristic: Involving or serving as an aid to learning, discovery or problem solving by experimental and especially trial-and-error methods Of or relating to exploratory problem-solving techniques that utilize self-educating techniques to improve performance 
horizontal reuse:Horizontal reuse provides generic reusable components that can support a variety of products. In other words, the components can be reused in different domains or product families.
horizontal traceability:Expresses relationships between software artefacts that reside in different phases of the software life-cycle, e.g. dependencies between a requirements specification and a design component See also vertical traceability
hypothesis:A tentative explanation that accounts for a set of facts and can be tested by further investigation a theory The hypothesis is the tentative theory of supposition that you think explains the behaviour you want to explore. Wherever possible, you should try to state your hypothesis in quantifiable terms, so that it is easy to tell whether the hypothesis is confirmed or refuted . See also research hypothesis, statistical hypothesis. 
impact analysis:Impact analysis tries to assess the impact of changes on the rest of the system when a certain component changes, which system parts will be affected, and how will they be affected See also change propagation
implementation:The phase in the software life-cycle where the actual software is implemented. The result of this phase consists of source code, together with documentation to make the code more readable.
inconsistency:A state in which two or more overlapping elements of different software models make assertions about aspects of the system they describe which are not jointly satisfiable .
inconsistency management:The process by which inconsistencies between software models are handled so as to support the goals of the stakeholders concerned .
integrity:The ability of software systems to protect their various components against unauthorized access and modification 
intercession:Intercession is the ability of a program to modify its own execution state or to alter its own interpretation or meaning . See also reflection
introspection:Introspection is the ability of a program to observe and therefore reason about its own state . See also reflection
invocation latency:The time from application invocation to when execution of the program actually begins .
iterative incremental software development:The process of developing a software system in small steps by iterating a number of times over the different software phases.
law:A statement that predicts behavior under certain defined conditions, that is based on facts, reason, and observation, and that is accepted as true. There are no established laws in software engineering 
level of significance:Probability of rejecting the null hypothesis when it is true 
maintainability:The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or adapt to a changed environment 
maintenance:See software maintenance
measure:A measure provides a quantitative indication of the extent, amount, dimensions, capacity or size of some attribute of a product or process. 
measurement:The process by which numbers or symbols are assigned to attributes of entities in the real world in such a way as to describe them according to clearly defined rules The experimental process in which, to precisely describe the entities or events in real world, numbers or other symbols are assigned to its attributes by using a given scale. The result of the measurement is called a measure. The act of determining a measure. 
metric:A quantitative measure of the degree to which a system, component or process possesses a given attribute. See also software metric
mixin:A mixin is a subclass definition that may be applied to different superclasses to create a related family of modified classes A mixin is a free-standing class extension function that abstracts over its own superclass 
model:A model is a simplified representation of a system or phenomenon with any hypotheses required to describe the system or explain the phenomenon, often mathematically. It is an abstraction of reality emphasizing those aspects that are of interest to someone 
modify-and-retrofit reuse:The opposite of copy-and-modify reuse. Instead of copying a component and making changes to the copy, the original component is modified directly. Since this has an impact on all the other components that make use of it, we might need to make modifications to these components as well. This often leads to a propagation of changes throughout the entire software system.
null hypothesis :A statement concerning one or more parameters that is subjected to statistical test . The hypothesis that there is no significant difference between two treatments . The null hypothesis is assumed to be true unless the data indicates otherwise . See also alternative hypothesis, statistical hypothesis.
object-oriented design:A software development technique in which a system or component is expressed in terms of objects and connections between those objects 
object-oriented language:A programming language that allows the user to express a program in terms of objects and messages between those objects 
observation:A discrete instance of the phenomena being studied, e.g. a specific software module, a specific code review, an individual programmer 
paradigm:A point of view in which some principles, approaches, concepts, and even theories, have been stated uniformly. A set of assumptions about reality that, when applied to a particular situation, can be used as a guide for action. For example, the Quality Improvement Paradigm. A philosophical and theoretical framework of a scientific school or discipline within which theories, laws, and generalizations and the experiments performed in support of them are formulated. 
pattern:A standard design for addressing frequently occuring problems, described in a standard way 
perfective maintenance:Modification of a software product after delivery to improve performance or maintainability 
piecemeal growth:The process of design and implementation in which software is embellished, modified, reduced, enlarged, and improved through a process of repair rather than replacement. 
platform:A set of subsystems and technologies that provide a coherent set of functionality through interfaces and specified usage patterns, which any application supported by that platform can use without concern for the details of how the functionality provided by the platform is implemented 
platform model:Provides a set of technical concepts, representing the different kinds of parts that make up a platform and the services provided by that platform. 
population:All observations of the phenomena being studied, e.g. all software modules, all code reviews, all programmers 
portability:The ease of transferring software products to various hardware and software environments Portability is the property of a system which permits it to be mapped from one environment to a different environment 
power of test:Probability of rejecting the null hypothesis when the alternative hypothesis is true 
preliminary design: The process of analyzing design alternatives and defining the architecture, components, interfaces, and timing and sizing estimates for a system or component. The result of the process in . 
product family:See product line
product line:A collection of existing and potential products that address a coherent business area and share a set of similar characteristics. All these products are made by the same process and for the same purpose, and differ only in style, model or size.
product-line based reuse:A kind of reuse that exploits the commonalities in a product line and established the bounds of variability among the products, making it possible to develop common assets and streamlining the development process.
realisation:See refinement 
redocumentation:Redocumentation is the creation or revision of a semantically equivalent representation within the same relative abstraction level. The resulting forms of representation are usually considered alternative views intended for human audience. Redocumentation is the simplest and oldest form of reverse engineering, and many consider it to be an unintrusive, weak form of restructuring. The "re-" prefix implies that the intent is to recover documentation about the subject system that existed or should have existed. 
reengineering:Reengineering, also known as both renovation and reclamation, is the examination and alteration of a subject system to reconstitute it in a new form and the subsequent implementation of the new form. Reengineering generally includes some form of reverse engineering followed by some form of forward engineering or restructuring. This may include modifications with respect to new requirements not met by the original system. 
refactoring: A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behaviour. To restructure software by applying a series of refactorings without changing its observable behaviour. See also restructuring
refinement:A refinement is a detailed description that conforms to another . Everything said about the abstraction holds, perhaps in a somewhat different form, in the refinement 
reflection:Reflection is the ability of a program to manipulate as data, something representing the state of the program during its own execution. There are two aspects of such manipulation introspection and intercession. Both aspects require a mechanism for encoding execution state as data providing such an encoding is called reification .
reification:See reflection
reliability:Software reliability is the probability of a failure-free operation of a computer program in a specified environment for a specified time .
repairability : Repairability is the ability to facilitate the repair of defects .
replication:The collection of two or more observations under a set of identical experimental conditions Repetition of the basic experiment under identical experiments, rather than repeating measurements on the same experimental unit . 
requirement:a statement about what the proposed system will do that all stakeholders agree must be made true in order for the customer's problem to be adequately solved 
requirements phase:The phase in the software life-cycle where is defined what the system should do, i.e., what are the requirements 
requirements traceability:A software requirements specification is traceable if the origin of each of its requirements is clear and if it facilitates the referencing of each requirement in future development or enhancement documentation 
research hypothesis:A tentative theory or supposition provisionally adopted to account for certain facts and to guide in the investigation of others 
restructuring:Restructuring is the transformation from one representation form to another at the same relative abstraction level, while preserving the subject system's external behaviour . A restructuring transformation is often one of appearance, such as altering code to improve its structure in the traditional sense of structured design. While restructuring creates new versions that implement or propose change to the subject system, it does not normally involve modifications because of new requirements. However, it may lead to better observations of the subject system that suggest changes that would improve aspects of the system. Restructuring is often used as a form of preventive maintenance to improve the physical state of the subject system with respect to some preferred standard. It may also involve adjusting the subject system to meet new environmental constraints that do not involve reassessment at higher abstraction levels. 
reusability:The ability of software elements to serve for the construction of many different applications The degree to which a software module or other work product can be used in more than one computer program or software system 
reusable asset:A reusable asset is a tangible resource that is acquired or developed for the solution of multiple problems, such as specifications, designs, code, test cases, etc.
reuse:The process of adapting generalised components to various contexts of use Repeated use of an artifact, typically outside the original context in which the artifact was created 
reuse capability:The range of expected results in reuse effectiveness, proficiency, and efficiency that an organisation is able to achieve through its process.
reverse engineering:The process of developing a set of specifications for a complex hardware system by an orderly examination of specimens of that system. The process of analysing an existing system to identify its components and their interrelationships and create representations of the system in another form or at a higher level of abstraction. Reverse engineering is usually undertaken in order to redesign the system for better maintainability or to produce a copy of a system without access to the design from which it was originally produced. For example, one might take the executable code of a computer program, run it to study how it behaved with different input and then attempt to write a program oneself which behaved identially . An integrated circuit might also be reverse engineered by an unscrupulous company wishing to make unlicensed copies of a popular chip. The process of extracting software system information from source code Reverse engineering is the process of analyzing a subject system to identify the system's components and their interrelationships and create representations of the system in another form or at a higher level of abstraction. Reverse engineering generally involves extracting design artifacts and building or synthesizing abstractions that are less implementation-dependent. Reverse engineering in and of itself does not involve changing the subject system or creating a new system based on the reverse-engineered subject system. It is a process of examination, not a process of change or replication. 
ripple effect:The phenomenon where a change in one piece of a software system affects at least one other area of the same software system See also change propagation
robustness:The ability of software systems to react appropriately to abnormal conditions 
round-trip engineering:The seamless integration between design and source code, between modeling and implementation. With round-trip engineering a programmer generates code from a design, changes that code in a separate development environment, and recreates the adapted design diagram back from the source code An iteration between modelling, generating code, changing that code and mapping this code back to the original model 
sample:A subset of a population 
simplicity:The degree to which a system or component has a design and implementation that is straightforward and easy to understand 
software:Software is part of a system solution that can be encoded to execute on a computer as a set of instructions it includes all the associated documentation necessary to understand, transform and use that solution Software is the collection of computer programs, procedures, rules, and associated documentation and data Software is the non-hardware part, including associated documentation, of a system being implemented or implemented in part with a computer or an embedded processor 
software aging:Relates to the problem that the quality of software decreases, and the software entropy increases, as the software evolves over time.
software change:See software evolution
software configuration management :The discipline of managing and controlling change in the evolution of software systems. 
software engineering:The establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines. The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software that is, the application of engineering to software. The systematic activities involved in the design, implementation and testing of software to optimize its production and support. 
software entropy:The amount of disorder in a software system
software evolution:The life of the software after its initial development cycle . Any subsequent change to the software, such as bug fixes and adding new functionality, is considered to be software evolution. All programming activity that is intended to generate a new software version from an earlier operational version The application of software maintenance activities and processes that generate a new operational software version with a changed customer-experienced functionality or properties from a prior operational version together with the associated quality assurance activities and processes, and with the management of the activities and processes See also software maintenance
software maintenance:The process of modifying a software system or component after delivery to correct faults, improve performance or other attributes, or adapt to a changed environment. Modification of a software product after delivery to correct faults, to improve performance or other attributes, or to adapt the product to a modified environment The software product undergoes modification to code and associated documentation due to a problem or the need for improvement. The objective is to modify the existing software while preserving its integrity The deliberate application of activities and processes, whether or not completed, to existing software that modify either the way the software directs hardware of the system, or the way the system contributes to the business of the system s stakeholders, together with the associated quality assurance activities and processes, and with the management of the activities and processes, and often done in the context of software evolution See also software evolution
software metric: A software metric is a combination from measures of attributes belonging to a software product, or to its development process, which shows quantitatively some of its characteristics. 
software life-cycle:The phases a software product goes through between when it is conceived and when it is no longer available for use.The software life-cycle typically includes the following requirements analysis, design, construction, testing , installation, operation, maintenance, and retirement.The development process tends to run iteratively through these phases rather than linearly several models have been proposed to describe this process.Other processes associated with a software product are quality assurance, marketing, sales and support. 
specialisation interface of a class:The specialization interface is used to extend and modify classes. It is accessed by making a subclass and adding messages and methods, refining types, or overriding methods. The last of these, overriding methods, is the operation that can modify behaviour and than can interact with the internal structure of the class. See also client interface
statistic:A descriptive measure of a sample, e.g., mean 
statistical hypothesis:A statement about one or more parameters of a population. The null hypothesis and alternative hypothesis are two forms of a statistical hypothesis 
statistical model:A mathematical statement concerning the sampling distribution of a random variable that is used in evaluating the outcome of an experiment or in predicting the outcome of future replications of an experiment .
statistical test:A statistic whose purpose is to provide a test of some statistical hypothesis. Test statistics such as t and F have known sampling distributions that can be employed in determining the probability of an obtained result under the null hypothesis .
structured design: Any disciplined approach to software design that adheres to specified rules based on principles such as modularity, top-down design, and stepwise refinement of data, system structures, and processing steps. The result of applying the approach in . 
survey:A survey is a retrospective study of a situation to try to document relationships and outcomes. A survey is always done after an event has occurred. When performing a suvey, you have no control over the situation at hand. That is, because it is a retrospective study, you can record a situation and compare it with similar ones. But you cannot manipulate variables as you do with case studies and experiments. Surveys try to poll what is happening broadly over large groups of projects "research in the large" . 
systematic reuse:Reuse is not restricted to certain phases of the software life-cycle, and even not to single applications. The idea of systematic reuse is that reuse takes place continuously during the entire software development process. Consequently, systematic software reuse corresponds to the purposeful creation, management and application of reusable assets.
testing:The phase in the software life-cycle that aims at uncovering defects by executing specialised test programs and test cases. The activity of uncovering defects in an implementation by comparing its behaviour against that of its specification under a given set of runtime stimuli . 
timeliness:The ability of a software system to be released when or before its users want it 
traceability:The degree to which a relationship can be established between two or more products of the development process, especially products having a predecessor-successor or master-subordinate relationship to one another for example, the degree to which the requirements and design of a given software component match. The degree to which each element in a software development product establishes its reason for existing for example, the degree to which each element in a bubble chart references the requirement that it satisfies See also requirements traceability
traceability analysis:The same as dependency analysis, but it usually involves examining dependency relationships between software artefacts at different phases of the software life-cycle, e.g. a dependency between a requirements specification and a corresponding design component.
transformation:The automatic generation of a target model from a source model, according to a transformation definition. 
transformation definition:a set of transformation rules that together describe how a model in the source language can be transformed into a model in the target language. 
transformation rule:a description of how one or more constructs in the source language can be transformed into one or more constructs in the target language. 
usability:Usability of a software product is the extent to which the product is convenient and practical to use .
variabilities:The set of features or properties of a component that vary, or differ, between systems.
verifiability:The ease of preparing acceptance procedures, especially test data, and procedures for detecting failures and tracing them to errors during the validation and operation phases 
vertical reuse:Vertical reuse is the process of developing components that can only be reused in a given product family.
vertical traceability:Expresses relationships between software artefacts in the same phase of the software life-cycle. In this sense, it is the same as dependency analysis, but not necessarily restricted to the implementation phase. See also horizontal traceability
view:A view is a representation of a whole system from the perspective of a related set of concerns. 
viewpoint:A viewpoint is a specification of the conventions for constructing and using a view. 
